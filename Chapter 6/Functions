6.1 Function Basics
//A function definition typically consists of a return type, a name, a list of zero or more parameters, and a body.
//The actions that the function performs are specified in a statement block referred to as the function body.

//We execute a function through the call operator, which is a pair of parentheses.
//The call operator takes an expression that is a function or points to a function.
//Inside the parentheses is a comma-separated list of arguments.
//The arguments are used to initialze the unction's parameters.

//The type of a call expression is the return type off the function.

Writing a Function:

//Example:
//factorial of val is val * (val - 1) * (val - 2) . . .
((val - (val - 1) * 1)
int fact(int val)
{
  int ret = 1; // local variable to hold the result as we calculate it
  while ( val > 1)
    rek *= val--; // assign ret * val to ret and decrement val
    
  return ret;
}

//Our function is named fact.
//It takes one int parameter and returns an int value.

Calling a Function:

int main()
{
  int j = fact(50); // j equals 120.
    cout << "5! is " << j << endl;
    return 0;
}

//A function call does two things: It initializes the function's parameters from the corresponding argumens, and it transers control to that function.
//Execution of the calling function is suspended and execution of the called function begins.

Parameters and Arguments:
//Argument are the initializers for a function's parameters.
//The first argument initializes the first parameter, and so on.

Function Parameter List

void f1(){ /*...*/} // implicit void parameter list
void f2(void) {/* ... */ } // explicit void parameter list

int f3 (int v1, v2) { /* ... */ } // error
int f4(int v1, int v2) { /*...*/ } // ok

Function Return Type
//Most types can be used as the return type of a function.
//In particular, the return type can be void, which means that the function does not return a value.

6.1.1 Local Objects
//In C++, names have scope and objects have lifetimes.
//Key concepts
-The scope of a name is the part of the program's text in which that name is visible.
-The lifetime of an object is the time during the program's execution that the object exists.

-Parameters and variables defined inside a function body are referred to as local variables.
-They are "local" to that function and hide declarations of the same name made in an outer scope.

Automatic object:
//Objects that exists only while a block is executing are known as automatic objects.
//After execution exits a block, the values of the automatic objects created in that block are underfined.

Local static Objects:
//Each local static object is initialized before the first time execution passes through the object's definition. 
//Local staticS are not destroyed when a function endsl they are destroyed when the program terminates.

size_t count_calls()
{
  static size_t ctr = 0; // value will persists across calls
  return ++Ctr;
}
int main()
{
  for (size_t i = 0; i != 10; ++i)
    cout << count_calls() << endl;
  return 0;
}

6.1.2 Function Declarations
//A function may be defined only oce but may be declared multiple times.
//With one exception that we'll cover in, we can declare a function that is not defined as long as we never use that function.
//A function declaration is just like a function definition except that a declaration has no function body.
//In a declaration, a semicolon replaces the function body.
//Because a function declaration has no body, there is no need for parameter names.

//parameter names chosen to indicate that the iterators
denote a range of values to print
void print (vector <int> :: const_iterator beg, vector <int> :: const_iterator end);

//There three elements are the return type, function name, and parameter types- describe the function's interface.

Function Declarations Go in Header Files
//Recall the varaibles are declaraed in header files and defined in source files.

6.1.3 Separate Compilation
//As our programs get more complicated, we'll want to stroe the various parts of the program in separate files.
//Separate Compilation lets us spilt our programs into several files, each of which can be compiled independently

Compiling and Linking Multiple Source Files
//As an example, assume that the definition of our fact function is in a file named fact.cc file, and its declaration is in a header file named Chapter 6.h.
//Our fact.cc file, like any file that uses these functions, will include the Chapter6.h header.
//We'll store a main function that cals fact in a second file named factMain.cc.
//To produce an executable file, we must tell the compiler where to find all of the code we use.

For instance:
$ CC factMain.cc fact.cc # generates factMain.exe or a.out 
$ CC factMain.cc fact.cc -o main # generates main or main.exe

Here cc is the name of our compiler, $ is our system prompt, and # begins a command-line comment.

6.2 Argument Passing
//When a parameter is a reference, we say that its corresponding argument is "passed by reference" or that the function is "called by reference."
//When the argument value is copied, the parameter and argument are independent objects. Wwe say such argument are "passed by value" or alternatively that the function is "called by value".

6.2.1 Passing Argument by Value
//When we initialize a nonreference type variables, the value of the initializer is copied.
//Changes made to the variable have no effect on the initializer:

int n = 0;  // ordinary variable of type int
int i = n; // i is a copy o the value in n
i = 42; // value in i is changed; n is unchanged 

ret *= val--; // decrements the value of val

//Although fact changes the value of val, that change has no effect on the argument passed to fact. 
//Calling fact(i) does not change the value of i.

Pointer Parameters 
//Pointers behave like any other nonreference type. 
//When we copy a pointer, the value of the pointer is copied.
//After the copy, the two pointers are distinct.
//However, a pointer also gives us indirect access to the object to which that pointer points.

int n = 0, i = 42;
int *p = &n, *q = &i; // p points to nl q points to i
*p = 42; // value in n is changed; p is unchanged 
p = q; // p now points to i : values in i and n are unchanged

//The same behavior applies to pointer paraments:
//function that takes a pointer and sets the pointed to value to zero 

void reset(int *ip)
{
  *ip = 0; // changes the value of the object to which ip points
   ip = 0; // changes only the local copy of ip; the argument is unchanged
}

//After a call to reset, the object to which the argument points will be 0, but the pointer argument itself is unchanged:

int i = 42;
reset(&i);    // changes i but not the address of i address of i
cout << "i = " << i << endl; // prints i = 0;

6.2.2 Passing Arguments by Reference:
//Recall that operations on a reference are actually operations on the object to which the reference refers:

int n = 0, i = 42;
int &r = n; // r is bound to n (i.e., r is another name for n)
r = 42; // n is now 42
r = i; //n now has the same value as i
i = r; // i has the same value as n

//function that takes a reference to an int and sets the given object to zero
void reset(int &i) // i is just another name for the object passed to reset.
  i = 0; // changes the value of the object to which i refers
  }
  
 Using References to Avoid Copies
 //Functions must use reference parameters to operate on objects of a type that cannot be copied.
 
 
 //compare the length of two strings
 bool isShorter(const string &s1, const string &s2)
 {
    return s1.soze() < s2.size();
 }
 
 Using Reference Parameters to Return Additional Information
 //returns the index of the first occurrence of c in s
 // the reference oarameter occur counts how often c occurs
 string :: size_type find_char(const string &s, char c, string :: size_type & occurs)
 {
  auto ret = s.size(); // position of the ffirst occurence, if any 
  occurs = 0; // set the occurence count parameter
  for ( decltype(ret) i = 0; i != s.size(); ++i){
    if (s[i] == c) {
       if (ret == s.size()){
        ret = i; // remember the first occurence of c
        ++occurs; // increment the occurrence count
       }
    }
  }
  return ret; // count is returned implicitly in occurs
 }
  




  
